!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BUF	.\evnet\buffer.h	/^typedef struct buffer BUF;$/;"	t	typeref:struct:buffer
BUFF_INIT_SIZE	.\evnet\buffer.h	12;"	d
BUFF_LEFT	.\evnet\buffer.h	21;"	d
BUFF_REAL_LEFT	.\evnet\buffer.h	23;"	d
BUFF_SETRIND	.\evnet\buffer.h	25;"	d
BUFF_SETWIND	.\evnet\buffer.h	26;"	d
BUFF_SIZE	.\evnet\buffer.h	24;"	d
BUFF_USED	.\evnet\buffer.h	22;"	d
BUF_P	.\evnet\buffer.h	/^typedef struct buffer* BUF_P;$/;"	t	typeref:struct:buffer
CACHED_TIME	.\evbase\util.h	141;"	d
DEFINE_TEST	.\evbase\util.h	18;"	d
DEFINE_TEST	.\evbase\util.h	21;"	d
EBL_P	.\evbase\evt.h	/^typedef struct evt_base_list* EBL_P;$/;"	t	typeref:struct:evt_base_list
EB_P	.\evbase\evt.h	/^typedef struct evt_base* EB_P;$/;"	t	typeref:struct:evt_base
EEPOLL_P	.\evbase\epoll.h	/^typedef struct evt_epoll* EEPOLL_P;$/;"	t	typeref:struct:evt_epoll
EL_P	.\evbase\evt.h	/^typedef struct evt_loop* EL_P;$/;"	t	typeref:struct:evt_loop
EPOLL_INIT_NEVENT	.\evbase\epoll.h	12;"	d
EPOLL_MAX_NEVENT	.\evbase\epoll.h	13;"	d
EP_EVT	.\evbase\epoll.h	/^typedef struct epoll_event EP_EVT;$/;"	t	typeref:struct:epoll_event
EP_P	.\evbase\evt.h	/^typedef struct evt_pool* EP_P;$/;"	t	typeref:struct:evt_pool
EVBASE_EPOLL_H	.\evbase\epoll.h	2;"	d
EVBASE_EVT_H	.\evbase\evt.h	2;"	d
EVBASE_LOG_H	.\evbase\log.h	2;"	d
EVBASE_THREAD_H	.\evbase\thread.h	2;"	d
EVBASE_UTIL_H	.\evbase\util.h	2;"	d
EVNET_BUFFER_H	.\evnet\buffer.h	2;"	d
EVNET_TCPCV_H	.\evnet\tcpsv.h	2;"	d
EVNET_UDPSV_H	.\evnet\udpsv.h	2;"	d
EVT_BASE	.\evbase\evt.h	18;"	d
EVT_BASE_LIST	.\evbase\evt.h	25;"	d
EVT_CALLBACK	.\evbase\evt.h	15;"	d
EVT_READ	.\evbase\evt.h	113;"	d
EVT_WRITE	.\evbase\evt.h	114;"	d
FDI_P	.\evbase\evt.h	/^typedef struct fd_info* FDI_P;$/;"	t	typeref:struct:fd_info
FD_FLAG_CHANGE	.\evbase\evt.h	116;"	d
HEAP_DELETE	.\evbase\util.h	110;"	d
HEAP_FIX_DOWN	.\evbase\util.h	75;"	d
HEAP_FIX_UP	.\evbase\util.h	63;"	d
HEAP_INIT	.\evbase\util.h	93;"	d
HEAP_POP	.\evbase\util.h	127;"	d
HEAP_PUSH	.\evbase\util.h	122;"	d
HEAP_SORT	.\evbase\util.h	99;"	d
HEAP_UPDATE_POS	.\evbase\util.h	60;"	d
LCHILD	.\evbase\util.h	55;"	d
LOG_BUFSIZE	.\evbase\log.h	30;"	d
LOG_DEBUG	.\evbase\log.h	14;"	d
LOG_DEBUG_INDEX	.\evbase\log.h	22;"	d
LOG_ERROR	.\evbase\log.h	16;"	d
LOG_ERROR_INDEX	.\evbase\log.h	24;"	d
LOG_FATAL	.\evbase\log.h	17;"	d
LOG_FATAL_INDEX	.\evbase\log.h	25;"	d
LOG_INNER	.\evbase\log.h	12;"	d
LOG_INNER_INDEX	.\evbase\log.h	20;"	d
LOG_LEVELS	.\evbase\log.h	26;"	d
LOG_MASK	.\evbase\log.h	18;"	d
LOG_TRACE	.\evbase\log.h	13;"	d
LOG_TRACE_INDEX	.\evbase\log.h	21;"	d
LOG_WARN	.\evbase\log.h	15;"	d
LOG_WARN_INDEX	.\evbase\log.h	23;"	d
LOOP_INIT_EVTSIZE	.\evbase\evt.h	130;"	d
LOOP_INIT_FDS	.\evbase\evt.h	128;"	d
LOOP_INIT_PENDSIZE	.\evbase\evt.h	129;"	d
LOOP_INIT_POLLUS	.\evbase\evt.h	132;"	d
LOOP_PRIORITY_MAX	.\evbase\evt.h	131;"	d
LOOP_STATU_INIT	.\evbase\evt.h	121;"	d
LOOP_STATU_PAUSE	.\evbase\evt.h	124;"	d
LOOP_STATU_QUITING	.\evbase\evt.h	125;"	d
LOOP_STATU_RUNNING	.\evbase\evt.h	123;"	d
LOOP_STATU_STARTED	.\evbase\evt.h	122;"	d
LOOP_STATU_STOP	.\evbase\evt.h	126;"	d
LSHIFT	.\evbase\util.h	54;"	d
MICOR_SECOND	.\evbase\util.h	138;"	d
RCHILD	.\evbase\util.h	56;"	d
RSHIFT	.\evbase\util.h	53;"	d
SA	.\evnet\tcpsv.h	/^typedef struct sockaddr_in SA;$/;"	t	typeref:struct:sockaddr_in
SA	.\evnet\udpsv.h	/^typedef struct sockaddr_in SA;$/;"	t	typeref:struct:sockaddr_in
SA_P	.\evnet\tcpsv.h	/^typedef struct sockaddr_in* SA_P;$/;"	t	typeref:struct:sockaddr_in
SA_P	.\evnet\udpsv.h	/^typedef struct sockaddr_in* SA_P;$/;"	t	typeref:struct:sockaddr_in
SECOND	.\evbase\util.h	139;"	d
STRING	.\evbase\util.h	17;"	d
STRING	.\evbase\util.h	20;"	d
TCPCLT_P	.\evnet\tcpsv.h	/^typedef struct tcp_clt* TCPCLT_P;$/;"	t	typeref:struct:tcp_clt
TCPSRV_P	.\evnet\tcpsv.h	/^typedef struct tcp_srv* TCPSRV_P;$/;"	t	typeref:struct:tcp_srv
TCP_CLIENT_WAITCLS	.\evnet\tcpsv.h	27;"	d
TCP_DEFAULT_FLAG	.\evnet\tcpsv.h	20;"	d
TCP_SERVER_ACBLOCK	.\evnet\tcpsv.h	25;"	d
TCP_SERVER_BREATH	.\evnet\tcpsv.h	22;"	d
TCP_SERVER_LOOPS	.\evnet\tcpsv.h	23;"	d
TCP_SERVER_NOREUSE	.\evnet\tcpsv.h	24;"	d
THREAD_FUNCTION	.\evbase\thread.h	90;"	d
THREAD_ID	.\evbase\thread.h	13;"	d
THREAD_RETURN	.\evbase\thread.h	91;"	d
TIMERP_CMP	.\evbase\evt.h	98;"	d
UDPSRV_P	.\evnet\udpsv.h	/^typedef struct udp_srv* UDPSRV_P;$/;"	t	typeref:struct:udp_srv
UDP_BUFSZIE	.\evnet\udpsv.h	17;"	d
UDP_DEFAULT_FLAG	.\evnet\udpsv.h	19;"	d
UDP_SERVER_BLOCK	.\evnet\udpsv.h	21;"	d
UDP_SERVER_NOREUSE	.\evnet\udpsv.h	20;"	d
add_one	.\evbase\util.h	31;"	d
addr	.\evnet\tcpsv.h	/^    SA addr;$/;"	m	struct:tcp_clt
addr	.\evnet\tcpsv.h	/^    SA addr;$/;"	m	struct:tcp_srv
addr	.\evnet\udpsv.h	/^    SA addr;$/;"	m	struct:udp_srv
adjust_between	.\evbase\util.h	47;"	d
alloc	.\evbase\thread.h	/^    void *(*alloc)(int);$/;"	m	struct:cond_ops
alloc	.\evbase\thread.h	/^    void *(*alloc)(int);$/;"	m	struct:lock_ops
atomic32	.\evbase\thread.h	/^typedef volatile int32_t atomic32;$/;"	t
atomic64	.\evbase\thread.h	/^typedef volatile int64_t atomic64;$/;"	t
atomic_add_get	.\evbase\thread.h	23;"	d
atomic_decrement	.\evbase\thread.h	25;"	d
atomic_get	.\evbase\thread.h	21;"	d
atomic_get_add	.\evbase\thread.h	22;"	d
atomic_increment	.\evbase\thread.h	24;"	d
buf	.\evnet\buffer.h	/^    char *buf;$/;"	m	struct:buffer
buff_expand	.\evnet\buffer.c	/^int buff_expand(BUF_P buf, int size) {$/;"	f
buff_fd_read	.\evnet\buffer.c	/^int buff_fd_read(BUF_P buf, int fd) {$/;"	f
buff_fd_write	.\evnet\buffer.c	/^int buff_fd_write(BUF_P buf, int fd) {$/;"	f
buff_free	.\evnet\buffer.c	/^void buff_free(BUF_P buf) {$/;"	f
buff_init	.\evnet\buffer.c	/^void buff_init(BUF_P buf) {$/;"	f
buff_new	.\evnet\buffer.c	/^BUF_P buff_new() {$/;"	f
buff_peak	.\evnet\buffer.c	/^const char* buff_peak(BUF_P buf) {$/;"	f
buff_read	.\evnet\buffer.c	/^int buff_read(BUF_P buf, int len, char* dst, int dstlen) {$/;"	f
buff_readall	.\evnet\buffer.c	/^int buff_readall(BUF_P buf, char* dst, int dstlen) {$/;"	f
buff_write	.\evnet\buffer.c	/^int buff_write(BUF_P buf, const char* str, int len) {$/;"	f
buffer	.\evnet\buffer.h	/^struct buffer {$/;"	s
cached_time	.\evbase\util.c	/^__thread int64_t cached_time = 0;$/;"	v
check_and_expand_array	.\evbase\util.h	34;"	d
clt_io	.\evnet\tcpsv.h	/^    struct evt_io* clt_io[2];$/;"	m	struct:tcp_clt	typeref:struct:tcp_clt::evt_io
cltcnt	.\evnet\tcpsv.h	/^    atomic32 cltcnt;$/;"	m	struct:tcp_srv
cond_alloc	.\evbase\thread.h	79;"	d
cond_alloc_attr	.\evbase\thread.h	70;"	d
cond_broadcast	.\evbase\thread.h	82;"	d
cond_free	.\evbase\thread.h	80;"	d
cond_free_attr	.\evbase\thread.h	72;"	d
cond_ops	.\evbase\thread.h	/^struct cond_ops {$/;"	s
cond_signal	.\evbase\thread.h	81;"	d
cond_signal_attr	.\evbase\thread.h	74;"	d
cond_t	.\evbase\thread.h	/^typedef void* cond_t;$/;"	t
cond_wait	.\evbase\thread.h	83;"	d
cond_wait_attr	.\evbase\thread.h	76;"	d
cond_wait_timed	.\evbase\thread.h	84;"	d
condname	.\evbase\thread.h	/^    const char* condname;$/;"	m	struct:cond_ops
cr_thread_id	.\evbase\thread.c	/^__thread int cr_thread_id = 0;$/;"	v
cr_thread_name	.\evbase\thread.c	/^__thread const char* cr_thread_name = "unknow";$/;"	v
default_log_if	.\evbase\log.c	/^struct log_if *default_log_if = &default_log_if_s;$/;"	v	typeref:struct:log_if
default_log_if_s	.\evbase\log.c	/^static struct log_if default_log_if_s = {$/;"	v	typeref:struct:log_if	file:
e	.\main.c	/^struct evt_io e, e2;$/;"	v	typeref:struct:evt_io
e2	.\main.c	/^struct evt_io e, e2;$/;"	v	typeref:struct:
ea1	.\main.c	/^struct evt_after ea1, ea2;$/;"	v	typeref:struct:evt_after
ea2	.\main.c	/^struct evt_after ea1, ea2;$/;"	v	typeref:struct:
eb1	.\main.c	/^struct evt_before eb1, eb2;$/;"	v	typeref:struct:evt_before
eb2	.\main.c	/^struct evt_before eb1, eb2;$/;"	v	typeref:struct:
empty_ev	.\evbase\evt.h	/^    struct evt_before *empty_ev;   \/* be used when stop a pending event *\/$/;"	m	struct:evt_loop	typeref:struct:evt_loop::evt_before
epoll_destroy	.\evbase\epoll.c	/^void epoll_destroy(EL_P loop) {$/;"	f
epoll_dispatch	.\evbase\epoll.c	/^int epoll_dispatch(EL_P loop) {$/;"	f
epoll_init	.\evbase\epoll.c	/^void *epoll_init(EL_P loop) {$/;"	f
epoll_update	.\evbase\epoll.c	/^int epoll_update(EL_P loop, int fd, uint8_t oev, uint8_t nev) {$/;"	f
et1	.\main.c	/^struct evt_timer et1, et2, et3;$/;"	v	typeref:struct:evt_timer
et2	.\main.c	/^struct evt_timer et1, et2, et3;$/;"	v	typeref:struct:
et3	.\main.c	/^struct evt_timer et1, et2, et3;$/;"	v	typeref:struct:
event	.\evbase\epoll.h	/^    struct epoll_event *event;$/;"	m	struct:evt_epoll	typeref:struct:evt_epoll::epoll_event
event	.\evbase\evt.h	/^    uint8_t event;$/;"	m	struct:evt_io
events	.\evbase\evt.h	/^    uint8_t events;$/;"	m	struct:fd_info
evt_after	.\evbase\evt.h	/^struct evt_after {$/;"	s
evt_after_init	.\evbase\evt.h	87;"	d
evt_after_start	.\evbase\evt.c	/^void evt_after_start(EL_P loop, struct evt_after* ev) {$/;"	f
evt_after_stop	.\evbase\evt.c	/^void evt_after_stop(EL_P loop, struct evt_after* ev) {$/;"	f
evt_afters_head	.\evbase\evt.h	/^    EBL_P evt_afters_head;$/;"	m	struct:evt_loop
evt_append_pending	.\evbase\evt.c	/^void evt_append_pending(EL_P loop, void *w) {$/;"	f
evt_base	.\evbase\evt.h	/^struct evt_base {$/;"	s
evt_base_init	.\evbase\evt.h	65;"	d
evt_base_list	.\evbase\evt.h	/^struct evt_base_list {$/;"	s
evt_before	.\evbase\evt.h	/^struct evt_before {$/;"	s
evt_before_init	.\evbase\evt.h	86;"	d
evt_before_start	.\evbase\evt.c	/^void evt_before_start(EL_P loop, struct evt_before* ev) {$/;"	f
evt_before_stop	.\evbase\evt.c	/^void evt_before_stop(EL_P loop, struct evt_before* ev) {$/;"	f
evt_befores_head	.\evbase\evt.h	/^    EBL_P evt_befores_head;$/;"	m	struct:evt_loop
evt_epoll	.\evbase\epoll.h	/^struct evt_epoll {$/;"	s
evt_execute_pending	.\evbase\evt.c	/^void evt_execute_pending(EL_P loop) {$/;"	f
evt_fd_change	.\evbase\evt.c	/^void evt_fd_change(EL_P loop, int fd) {$/;"	f
evt_fd_changes_update	.\evbase\evt.c	/^void evt_fd_changes_update(EL_P loop) {$/;"	f
evt_io	.\evbase\evt.h	/^struct evt_io{$/;"	s
evt_io_init	.\evbase\evt.h	74;"	d
evt_io_start	.\evbase\evt.c	/^void evt_io_start(EL_P loop, struct evt_io* w) {$/;"	f
evt_io_stop	.\evbase\evt.c	/^void evt_io_stop(EL_P loop, struct evt_io *ev) {$/;"	f
evt_list_add	.\evbase\evt.c	/^static void evt_list_add(EBL_P* head, EBL_P elm) {$/;"	f	file:
evt_list_add_tail	.\evbase\evt.c	/^static void evt_list_add_tail(EBL_P* head, EBL_P elm) {$/;"	f	file:
evt_list_del	.\evbase\evt.c	/^static void evt_list_del(EBL_P* head, EBL_P elm) {$/;"	f	file:
evt_loop	.\evbase\evt.h	/^struct evt_loop {$/;"	s
evt_loop_destroy	.\evbase\evt.c	/^int evt_loop_destroy(EL_P loop) {$/;"	f
evt_loop_init	.\evbase\evt.c	/^EL_P evt_loop_init() {$/;"	f
evt_loop_init_with_flag	.\evbase\evt.c	/^EL_P evt_loop_init_with_flag(int flag) {$/;"	f
evt_loop_quit	.\evbase\evt.c	/^int evt_loop_quit(EL_P loop) {$/;"	f
evt_loop_run	.\evbase\evt.c	/^int evt_loop_run(EL_P loop) {$/;"	f
evt_pool	.\evbase\evt.h	/^struct evt_pool {$/;"	s
evt_set_data	.\evbase\evt.h	63;"	d
evt_timer	.\evbase\evt.h	/^struct evt_timer{$/;"	s
evt_timer_init	.\evbase\evt.h	80;"	d
evt_timer_start	.\evbase\evt.c	/^void evt_timer_start(EL_P loop, struct evt_timer* ev) {$/;"	f
evt_timer_stop	.\evbase\evt.c	/^void evt_timer_stop(EL_P loop, struct evt_timer* ev) {$/;"	f
fd	.\evbase\epoll.h	/^    int fd;$/;"	m	struct:evt_epoll
fd	.\evbase\evt.h	/^    int fd;$/;"	m	struct:evt_io
fd	.\evnet\tcpsv.h	/^    int fd;$/;"	m	struct:tcp_clt
fd	.\evnet\tcpsv.h	/^    int fd;$/;"	m	struct:tcp_srv
fd	.\evnet\udpsv.h	/^    int fd;$/;"	m	struct:udp_srv
fd_cloexec	.\evbase\util.c	/^int fd_cloexec(int fd) {$/;"	f
fd_info	.\evbase\evt.h	/^struct fd_info {$/;"	s
fd_nonblock	.\evbase\util.c	/^int fd_nonblock(int fd) {$/;"	f
fd_reuse	.\evbase\util.c	/^int fd_reuse(int fd) {$/;"	f
fds	.\evbase\evt.h	/^    FDI_P fds;$/;"	m	struct:evt_loop
fds_mod	.\evbase\evt.h	/^    int *fds_mod;$/;"	m	struct:evt_loop
fds_mod_cnt	.\evbase\evt.h	/^    int fds_mod_cnt;$/;"	m	struct:evt_loop
fds_mod_size	.\evbase\evt.h	/^    int fds_mod_size;$/;"	m	struct:evt_loop
fds_size	.\evbase\evt.h	/^    int fds_size;$/;"	m	struct:evt_loop
feature	.\evbase\epoll.h	/^    int feature;$/;"	m	struct:evt_epoll
feature	.\evbase\thread.h	/^    int feature;$/;"	m	struct:cond_ops
feature	.\evbase\thread.h	/^    int feature;$/;"	m	struct:lock_ops
flag	.\evbase\evt.h	/^    uint8_t flag;$/;"	m	struct:fd_info
flag	.\evnet\tcpsv.h	/^    int flag;$/;"	m	struct:tcp_srv
flag	.\evnet\tcpsv.h	/^    uint8_t flag;$/;"	m	struct:tcp_clt
flag	.\evnet\udpsv.h	/^    int flag;$/;"	m	struct:udp_srv
flush_cb	.\evbase\log.h	/^    void (*flush_cb)();$/;"	m	struct:log_if
free	.\evbase\thread.h	/^    void (*free)(void *, int);$/;"	m	struct:cond_ops
free	.\evbase\thread.h	/^    void (*free)(void *, int);$/;"	m	struct:lock_ops
get_cached_time	.\evbase\util.c	/^int64_t get_cached_time() {$/;"	f
get_default_logif_level_flag	.\evbase\log.h	63;"	d
get_logif_level_flag	.\evbase\log.h	45;"	d
get_next_loop	.\evnet\tcpsv.h	/^    EL_P (*get_next_loop)(TCPSRV_P);$/;"	m	struct:tcp_srv
head	.\evbase\evt.h	/^    EBL_P head;$/;"	m	struct:fd_info
heap_pos	.\evbase\evt.h	/^    int heap_pos;$/;"	m	struct:evt_timer
ignore_sigpipe	.\evbase\util.c	/^int ignore_sigpipe() {$/;"	f
inbuf	.\evnet\tcpsv.h	/^    BUF_P inbuf;$/;"	m	struct:tcp_clt
init_array_noop	.\evbase\util.h	33;"	d
init_array_zero	.\evbase\util.h	32;"	d
level_cb	.\evbase\log.h	/^    void (*level_cb[LOG_LEVELS])();$/;"	m	struct:log_if
level_flag	.\evbase\log.h	/^    uint8_t level_flag;$/;"	m	struct:log_if
lock	.\evbase\thread.h	/^    int (*lock)(void *, int);$/;"	m	struct:lock_ops
lock_alloc	.\evbase\thread.h	52;"	d
lock_alloc_attr	.\evbase\thread.h	41;"	d
lock_free	.\evbase\thread.h	53;"	d
lock_free_attr	.\evbase\thread.h	43;"	d
lock_lock	.\evbase\thread.h	50;"	d
lock_lock_attr	.\evbase\thread.h	45;"	d
lock_ops	.\evbase\thread.h	/^struct lock_ops {$/;"	s
lock_t	.\evbase\thread.h	/^typedef void* lock_t;$/;"	t
lock_unlock	.\evbase\thread.h	51;"	d
lock_unlock_attr	.\evbase\thread.h	47;"	d
lockname	.\evbase\thread.h	/^    const char* lockname;$/;"	m	struct:lock_ops
log_append	.\evbase\log.c	/^void log_append(struct log_if *logif, uint8_t level_index, const char *fmt, ...) {$/;"	f
log_console_fatal_cb	.\evbase\log.c	/^static void log_console_fatal_cb() {$/;"	f	file:
log_console_flush_cb	.\evbase\log.c	/^static void log_console_flush_cb() {$/;"	f	file:
log_console_output_cb	.\evbase\log.c	/^static void log_console_output_cb(const char *str, size_t size) {$/;"	f	file:
log_debug	.\evbase\log.h	71;"	d
log_error	.\evbase\log.h	73;"	d
log_fatal	.\evbase\log.h	74;"	d
log_if	.\evbase\log.h	/^struct log_if {$/;"	s
log_inner	.\evbase\log.h	69;"	d
log_level_append	.\evbase\log.h	40;"	d
log_level_name	.\evbase\log.c	/^static const char* log_level_name[LOG_LEVELS] = {$/;"	v	file:
log_trace	.\evbase\log.h	70;"	d
log_warn	.\evbase\log.h	72;"	d
logu_debug	.\evbase\log.h	53;"	d
logu_error	.\evbase\log.h	55;"	d
logu_fatal	.\evbase\log.h	56;"	d
logu_inner	.\evbase\log.h	51;"	d
logu_trace	.\evbase\log.h	52;"	d
logu_warn	.\evbase\log.h	54;"	d
loop	.\evbase\evt.h	/^    EL_P *loop;$/;"	m	struct:evt_pool
loop_list	.\evnet\tcpsv.h	/^    EL_P *loop_list;$/;"	m	struct:tcp_srv
loop_on	.\evnet\tcpsv.h	/^    EL_P loop_on;$/;"	m	struct:tcp_clt
loop_on	.\evnet\tcpsv.h	/^    EL_P loop_on;$/;"	m	struct:tcp_srv
loop_on	.\evnet\udpsv.h	/^    EL_P loop_on;$/;"	m	struct:udp_srv
loops	.\evbase\evt.h	/^    int loops;$/;"	m	struct:evt_pool
loops	.\evnet\tcpsv.h	/^    int loops;$/;"	m	struct:tcp_srv
main	.\main.c	/^int main (int argc, char *argv[]) {$/;"	f
max	.\evbase\util.h	46;"	d
min	.\evbase\util.h	45;"	d
mm_free	.\evbase\util.c	/^void mm_free(void *p) {$/;"	f
mm_malloc	.\evbase\util.h	27;"	d
mm_realloc	.\evbase\util.c	/^void *mm_realloc(void *p, int size) {$/;"	f
multi_two	.\evbase\util.h	30;"	d
name	.\evnet\tcpsv.h	/^    char name[10];$/;"	m	struct:tcp_srv
name	.\evnet\udpsv.h	/^    char name[10];$/;"	m	struct:udp_srv
nevent	.\evbase\epoll.h	/^    int nevent;$/;"	m	struct:evt_epoll
now_to_string	.\evbase\util.c	/^void now_to_string(char* buf, int len) {$/;"	f
on_accept_comp	.\evnet\tcpsv.h	/^    void (*on_accept_comp)(TCPCLT_P);$/;"	m	struct:tcp_srv
on_accept_comp	.\main.c	/^void on_accept_comp(TCPCLT_P client) {$/;"	f
on_close_comp	.\evnet\tcpsv.h	/^    void (*on_close_comp)(int);$/;"	m	struct:tcp_srv
on_read	.\evnet\udpsv.h	/^    void (*on_read)(UDPSRV_P, SA_P, const char*, int);$/;"	m	struct:udp_srv
on_read_comp	.\evnet\tcpsv.h	/^    void (*on_read_comp)(TCPCLT_P, BUF_P, int);$/;"	m	struct:tcp_srv
on_read_comp	.\main.c	/^void on_read_comp(TCPCLT_P client, BUF_P buf, int len) {$/;"	f
on_udp_read	.\main.c	/^void on_udp_read(UDPSRV_P server, SA_P addr, const char* cont, int len) {$/;"	f
on_write_comp	.\evnet\tcpsv.h	/^    void (*on_write_comp)(TCPCLT_P, BUF_P, int);$/;"	m	struct:tcp_srv
on_write_comp	.\main.c	/^void on_write_comp(TCPCLT_P client, BUF_P buf , int len) {$/;"	f
outbuf	.\evnet\tcpsv.h	/^    BUF_P outbuf;$/;"	m	struct:tcp_clt
output_cb	.\evbase\log.h	/^    void (*output_cb)(const char*, size_t);$/;"	m	struct:log_if
owner_thread	.\evbase\evt.h	/^    int owner_thread;$/;"	m	struct:evt_loop
pending	.\evbase\evt.h	/^    EB_P *pending[LOOP_PRIORITY_MAX];$/;"	m	struct:evt_loop
pending_cnt	.\evbase\evt.h	/^    int pending_cnt[LOOP_PRIORITY_MAX];$/;"	m	struct:evt_loop
pending_size	.\evbase\evt.h	/^    int pending_size[LOOP_PRIORITY_MAX];$/;"	m	struct:evt_loop
poll_destroy	.\evbase\evt.h	/^    void (*poll_destroy)(EL_P);$/;"	m	struct:evt_loop
poll_dispatch	.\evbase\evt.h	/^    int (*poll_dispatch)(EL_P);$/;"	m	struct:evt_loop
poll_feature	.\evbase\evt.h	/^    int poll_feature;$/;"	m	struct:evt_loop
poll_init	.\evbase\evt.h	/^    void *(*poll_init)(EL_P);$/;"	m	struct:evt_loop
poll_more_ptr	.\evbase\evt.h	/^    void *poll_more_ptr;$/;"	m	struct:evt_loop
poll_time_us	.\evbase\evt.h	/^    int64_t poll_time_us;      \/*in microsecond*\/$/;"	m	struct:evt_loop
poll_update	.\evbase\evt.h	/^    int (*poll_update)(EL_P, int, uint8_t, uint8_t);$/;"	m	struct:evt_loop
priority_max	.\evbase\evt.h	/^    uint8_t priority_max;   \/* 0 ~ max*\/$/;"	m	struct:evt_loop
pthread_cond_lock_alloc	.\evbase\thread.c	/^static void *pthread_cond_lock_alloc(int mode) {$/;"	f	file:
pthread_cond_lock_free	.\evbase\thread.c	/^static void pthread_cond_lock_free(void *p, int mode) {$/;"	f	file:
pthread_cond_lock_signal	.\evbase\thread.c	/^static int pthread_cond_lock_signal(void *p, int mode) {$/;"	f	file:
pthread_cond_lock_wait	.\evbase\thread.c	/^static int pthread_cond_lock_wait(void *p, void *k, const struct timeval *timeout, int mode) {$/;"	f	file:
pthread_mutex_lock_alloc	.\evbase\thread.c	/^static void *pthread_mutex_lock_alloc(int mode) {$/;"	f	file:
pthread_mutex_lock_free	.\evbase\thread.c	/^static void pthread_mutex_lock_free(void *p, int mode) {$/;"	f	file:
pthread_mutex_lock_lock	.\evbase\thread.c	/^static int pthread_mutex_lock_lock(void *p, int mode) {$/;"	f	file:
pthread_mutex_lock_unlock	.\evbase\thread.c	/^static int pthread_mutex_lock_unlock(void *p, int mode) {$/;"	f	file:
r_ind	.\evnet\buffer.h	/^    int r_ind;$/;"	m	struct:buffer
relate_srv	.\evnet\tcpsv.h	/^    TCPSRV_P relate_srv;$/;"	m	struct:tcp_clt
repeat	.\evbase\evt.h	/^    int64_t repeat;$/;"	m	struct:evt_timer
revents	.\evbase\evt.h	/^    uint8_t revents;   \/* event return by poll*\/$/;"	m	struct:fd_info
scnet_cond_ops	.\evbase\thread.c	/^struct cond_ops scnet_cond_ops = {$/;"	v	typeref:struct:cond_ops
scnet_lock_ops	.\evbase\thread.c	/^struct lock_ops scnet_lock_ops = {$/;"	v	typeref:struct:lock_ops
set_cond_ops	.\evbase\thread.c	/^void set_cond_ops(struct cond_ops ops) {$/;"	f
set_default_logif_flush_cb	.\evbase\log.h	66;"	d
set_default_logif_level	.\evbase\log.h	62;"	d
set_default_logif_level_cb	.\evbase\log.h	67;"	d
set_default_logif_level_flag	.\evbase\log.h	64;"	d
set_default_logif_output_cb	.\evbase\log.h	65;"	d
set_lock_ops	.\evbase\thread.c	/^void set_lock_ops(struct lock_ops ops) {$/;"	f
set_logif_flush_cb	.\evbase\log.h	48;"	d
set_logif_level	.\evbase\log.h	44;"	d
set_logif_level_cb	.\evbase\log.h	49;"	d
set_logif_level_flag	.\evbase\log.h	46;"	d
set_logif_output_cb	.\evbase\log.h	47;"	d
signal	.\evbase\thread.h	/^    int (*signal)(void *cond, int);$/;"	m	struct:cond_ops
size	.\evnet\buffer.h	/^    int size;$/;"	m	struct:buffer
srv_io	.\evnet\tcpsv.h	/^    struct evt_io* srv_io;$/;"	m	struct:tcp_srv	typeref:struct:tcp_srv::evt_io
srv_io	.\evnet\udpsv.h	/^    struct evt_io* srv_io;$/;"	m	struct:udp_srv	typeref:struct:udp_srv::evt_io
status	.\evbase\evt.h	/^    uint8_t status;$/;"	m	struct:evt_loop
tcp_buffer_send	.\evnet\tcpsv.c	/^int tcp_buffer_send(TCPCLT_P client, BUF_P buf) {$/;"	f
tcp_client_close	.\evnet\tcpsv.c	/^static void tcp_client_close(TCPCLT_P client) {$/;"	f	file:
tcp_client_read	.\evnet\tcpsv.c	/^static void tcp_client_read(EL_P loop, struct evt_io* ev) {$/;"	f	file:
tcp_client_write	.\evnet\tcpsv.c	/^static void tcp_client_write(EL_P loop, struct evt_io* ev) {$/;"	f	file:
tcp_clt	.\evnet\tcpsv.h	/^struct tcp_clt {$/;"	s
tcp_delay_send	.\evnet\tcpsv.c	/^int tcp_delay_send(TCPCLT_P client, const char* str, int size, int mask) {$/;"	f
tcp_flush	.\evnet\tcpsv.c	/^int tcp_flush(TCPCLT_P client) {$/;"	f
tcp_send	.\evnet\tcpsv.c	/^int tcp_send(TCPCLT_P client, const char* str, int size) {$/;"	f
tcp_server_accpet	.\evnet\tcpsv.c	/^static void tcp_server_accpet(EL_P loop, struct evt_io* ev) {$/;"	f	file:
tcp_server_bind_loop	.\evnet\tcpsv.c	/^int tcp_server_bind_loop(TCPSRV_P server, EL_P loop) {$/;"	f
tcp_server_free	.\evnet\tcpsv.c	/^void tcp_server_free(TCPSRV_P server) {$/;"	f
tcp_server_init	.\evnet\tcpsv.c	/^TCPSRV_P tcp_server_init(int port, int flag) {$/;"	f
tcp_server_init_v1	.\evnet\tcpsv.c	/^TCPSRV_P tcp_server_init_v1(const char* addr_str, int port, int flag) {$/;"	f
tcp_server_init_v2	.\evnet\tcpsv.c	/^TCPSRV_P tcp_server_init_v2(SA *addr, int flag) {$/;"	f
tcp_set_accept_comp_cb	.\evnet\tcpsv.h	52;"	d
tcp_set_close_comp_cb	.\evnet\tcpsv.h	58;"	d
tcp_set_read_comp_cb	.\evnet\tcpsv.h	54;"	d
tcp_set_write_comp_cb	.\evnet\tcpsv.h	56;"	d
tcp_srv	.\evnet\tcpsv.h	/^struct tcp_srv {$/;"	s
thread_detach	.\evbase\thread.h	94;"	d
thread_id	.\evbase\thread.c	/^int thread_id() {$/;"	f
thread_join	.\evbase\thread.h	93;"	d
thread_name	.\evbase\thread.c	/^const char* thread_name() {$/;"	f
thread_start	.\evbase\thread.h	92;"	d
thread_t	.\evbase\thread.h	89;"	d
time_to_string	.\evbase\util.c	/^void time_to_string(int64_t micro_seconds, char* buf, int len) {$/;"	f
timer_heap	.\evbase\evt.h	/^    struct evt_timer** timer_heap;$/;"	m	struct:evt_loop	typeref:struct:evt_loop::evt_timer
timer_heap_cnt	.\evbase\evt.h	/^    int timer_heap_cnt;$/;"	m	struct:evt_loop
timer_heap_size	.\evbase\evt.h	/^    int timer_heap_size;$/;"	m	struct:evt_loop
timestamp	.\evbase\evt.h	/^    int64_t timestamp;$/;"	m	struct:evt_timer
udp_send	.\evnet\udpsv.c	/^void udp_send(UDPSRV_P server, SA_P addr, const char* cont, int len) {$/;"	f
udp_server_bind_loop	.\evnet\udpsv.c	/^int udp_server_bind_loop(UDPSRV_P server, EL_P loop) {$/;"	f
udp_server_free	.\evnet\udpsv.c	/^UDPSRV_P udp_server_free(UDPSRV_P server) {$/;"	f
udp_server_init	.\evnet\udpsv.c	/^UDPSRV_P udp_server_init(int port, int flag) {$/;"	f
udp_server_init_v1	.\evnet\udpsv.c	/^UDPSRV_P udp_server_init_v1(const char* s_addr, int port, int flag) {$/;"	f
udp_server_init_v2	.\evnet\udpsv.c	/^UDPSRV_P udp_server_init_v2(SA* addr, int flag) {$/;"	f
udp_server_read	.\evnet\udpsv.c	/^static void udp_server_read(EL_P loop, struct evt_io* ev) {$/;"	f	file:
udp_set_read_cb	.\evnet\udpsv.h	36;"	d
udp_srv	.\evnet\udpsv.h	/^struct udp_srv {$/;"	s
unlock	.\evbase\thread.h	/^    int (*unlock)(void *, int);$/;"	m	struct:lock_ops
update_cached_time	.\evbase\util.c	/^int64_t update_cached_time() {$/;"	f
w_ind	.\evnet\buffer.h	/^    int w_ind;$/;"	m	struct:buffer
wait	.\evbase\thread.h	/^    int (*wait)(void *cond, void *lock,$/;"	m	struct:cond_ops
